//import * as THREE from './three.min.js';

var container;

var camera, scene, renderer, raycaster;

var group;

var targetRotationx = 0;
var targetRotationOnMouseDownx = 0;
var targetRotationy = 0;
var targetRotationOnMouseDowny = 0;
var rotationDirectionx = 1;
var rotationDirectiony = 1;

var moveCamTo = new THREE.Vector3();

var doDisplay = false;
var doRaycast = false;

var onOffCubes = [];

var mouse = new THREE.Vector2(), INTERSECTED;
var mouseup = new THREE.Vector2();
var mousedown = new THREE.Vector2();
var mouseX = 0;
var mouseY = 0;
var mouseXOnMouseDown = 0;
var mouseYOnMouseDown = 0;

var touchScreen = false;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

var radius = -244, theta = 0;

init();
animate();

function init() {

    moveCamTo.x = 0;
    moveCamTo.y = 0;
    moveCamTo.z = -244;
    document.getElementById("closeButton").addEventListener("click", onHexClose);
    container = document.createElement( 'div' );
    document.body.appendChild( container );

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xffffff );

    camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 0, 0, radius );
    camera.lookAt( 0,0,0 );
    scene.add( camera );

    var light = new THREE.PointLight( 0xffffff, 0.8 );
    camera.add( light );

    group = new THREE.Group();
    group.position.y = 0;
    scene.add( group );

    window.addEventListener( 'mousemove', onMouseMove, false );

    raycaster = new THREE.Raycaster();

    var loader = new THREE.TextureLoader();
    var texture = loader.load( "./textures/grey.jpg" );

    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set( 0.01, 0.01 );

    function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s , t) {

        // flat shape with texture
        // note: default UVs generated by THREE.ShapeBufferGeometry are simply the x- and y-coordinates of the vertices

        // var geometry = new THREE.ShapeBufferGeometry( shape );
        var geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );

        var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: t } ) );

        mesh.position.set( x, y, z);
        mesh.rotation.set( rx, ry, rz );
        mesh.scale.set( s, s, s );
        group.add( mesh );
        onOffCubes.push( group )
        

        addLineShape( shape, color, x, y, z, rx, ry, rz, s );
        

    }

    function addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {

        // lines

        shape.autoClose = true;

        var points = shape.getPoints();
        var spacedPoints = shape.getSpacedPoints( 50 );

        var geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
        var geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );

        // solid line front

        var line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
        line.position.set( x, y, z - 1);
        line.rotation.set( rx, ry, rz );
        line.scale.set( s, s, s );
        
        group.add( line );

        // solid line rear

        var line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
        line.position.set( x, y, z + 11);
        line.rotation.set( rx, ry, rz );
        line.scale.set( s, s, s );
        
        group.add( line );
    }


    
    // Triangle



    var triangleShape = new THREE.Shape();
    triangleShape.moveTo( -9, 0 );
    triangleShape.lineTo( -4, 8.9 );
    triangleShape.lineTo( 4, 8.9 );
    triangleShape.lineTo( 9, 0 );
    triangleShape.lineTo( 4, -8.9 );
    triangleShape.lineTo( -4, -8.9 ); 
    triangleShape.lineTo( -9, 0 ); // close path

    // var triangleShape = new THREE.Shape();
    // triangleShape.moveTo( -10, 0 );
    // triangleShape.lineTo( -5, 10 );
    // triangleShape.lineTo( 5, 10 );
    // triangleShape.lineTo( 10, 0 );
    // triangleShape.lineTo( 5, -10 );
    // triangleShape.lineTo( -5, -10 ); 
    // triangleShape.lineTo( -10, 0 ); // close path
    var colorw = 0xffffff;
    var extrudeSettings = { depth: 10, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
    //var extrudeSettings = { depth: 10, bevelEnabled: false};

    //addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s )
    var rmax = 4;
    var x = 0;
    var y = 0;
    addShape( triangleShape, extrudeSettings, colorw, x, y, 0, 0, 0, 0, 1 ,texture);
    for (var i = 1; i <= rmax;i++){
        addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y+(i*10), 0, 0, 0, 0, 1 ,texture);
        addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y-(i*10), 0, 0, 0, 0, 1 ,texture);
        addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y+(i*10), 0, 0, 0, 0, 1 ,texture);
        addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y-(i*10), 0, 0, 0, 0, 1 ,texture);
        addShape( triangleShape, extrudeSettings, colorw, x, y+(i*20), 0, 0, 0, 0, 1 ,texture);
        addShape( triangleShape, extrudeSettings, colorw, x, y-(i*20), 0, 0, 0, 0, 1 ,texture);
        
        if (i === 2){
            addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+15, y+(i*15), 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-15, y+(i*15), 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+15, y-(i*15), 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-15, y-(i*15), 0, 0, 0, 0, 1 ,texture);
        }

        if (i === 3){
            addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y+10, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y-10, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y+10, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y-10, 0, 0, 0, 0, 1 ,texture);

            addShape( triangleShape, extrudeSettings, colorw, x+(i*10), y+40, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*10), y+40, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+(i*10), y-40, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*10), y-40, 0, 0, 0, 0, 1 ,texture);

            addShape( triangleShape, extrudeSettings, colorw, x+(i*5), y+50, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*5), y+50, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+(i*5), y-50, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*5), y-50, 0, 0, 0, 0, 1 ,texture);
        }

        if (i === 4){
            addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y+20, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+(i*15), y-20, 0, 0, 0, 0, 1 ,texture);

            addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y+20, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-(i*15), y-20, 0, 0, 0, 0, 1 ,texture);

            addShape( triangleShape, extrudeSettings, colorw, x+45, y+50, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+30, y+60, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+15, y+70, 0, 0, 0, 0, 1 ,texture);

            addShape( triangleShape, extrudeSettings, colorw, x+45, y-50, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+30, y-60, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x+15, y-70, 0, 0, 0, 0, 1 ,texture);

            addShape( triangleShape, extrudeSettings, colorw, x-45, y+50, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-30, y+60, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-15, y+70, 0, 0, 0, 0, 1 ,texture);

            addShape( triangleShape, extrudeSettings, colorw, x-45, y-50, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-30, y-60, 0, 0, 0, 0, 1 ,texture);
            addShape( triangleShape, extrudeSettings, colorw, x-15, y-70, 0, 0, 0, 0, 1 ,texture);
            
        }


    }

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    document.addEventListener( 'mousedown', onDocumentMouseDown, false );
    document.addEventListener( 'touchstart', onDocumentTouchStart, false );
    document.addEventListener( 'touchmove', onDocumentTouchMove, false );
    document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

    //

    window.addEventListener( 'resize', onWindowResize, false );

}

function isOdd(num) { return num % 2;}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

//



function onMouseMove( event ) {

    // calculate mouse position in normalized device coordinates
    // (-1 to +1) for both components

    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    doRaycast = true;

}

function onDocumentMouseMove( event ) {

    mouseX = event.clientX - windowHalfX;
    mouseY = event.clientY - windowHalfY;

    targetRotationx = targetRotationOnMouseDownx + ( mouseX - mouseXOnMouseDown ) * 0.02;
    targetRotationy = targetRotationOnMouseDowny - ( mouseY - mouseYOnMouseDown ) * 0.02;

    // if (targetRotationx > 1.5) targetRotationx = 1.5;
    // if (targetRotationx < -1.5) targetRotationx = -1.5;
    // if (targetRotationy > 1.5) targetRotationy = 1.5;
    // if (targetRotationy < -1.5) targetRotationy = -1.5;

    if ((mouseX - mouseXOnMouseDown) >= 0){
        rotationDirectionx = 1;
    } else if ((mouseX - mouseXOnMouseDown) < 0) {
        rotationDirectionx = -1;
    }

    if ((mouseY - mouseYOnMouseDown) >= 0){
        rotationDirectiony = -1;
    } else if ((mouseY - mouseYOnMouseDown) < 0) {
        rotationDirectiony = 1;
    }

}

function onDocumentMouseDown( event ) {

    mousedown.x = event.clientX;
    mousedown.y = event.clientY;

    event.preventDefault();

    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    document.addEventListener( 'mouseup', onDocumentMouseUp, false );
    document.addEventListener( 'mouseout', onDocumentMouseOut, false );

    mouseXOnMouseDown = event.clientX - windowHalfX;
    mouseYOnMouseDown = event.clientY - windowHalfY;
    targetRotationOnMouseDownx = targetRotationx;
    targetRotationOnMouseDowny = targetRotationy;
}

function onDocumentMouseUp( event) {

    if (!touchScreen){
        mouseup.x = event.clientX;
        mouseup.y = event.clientY;

        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
        
        if (mousedown.x === mouseup.x && mousedown.y === mouseup.y && INTERSECTED){
            onHexClick();
        }
    }
}

function onHexClick() {
    //doRaycast = false;
    //doRotation = false;
    doDisplay = true;
    moveCamTo.x = INTERSECTED.position.x;
    moveCamTo.y = INTERSECTED.position.y;
    moveCamTo.z = -30;
    INTERSECTED.material.emissive.setHex( 0x000000 );
    document.getElementById("closeDisplay").style.display = "inline-block";
    document.removeEventListener( 'mousewheel', onDocumentMouseWheel, false );
}

function onHexClose() {
    doDisplay = false;
    moveCamTo.x = 0;
    moveCamTo.y = 0;
    moveCamTo.z = -244;
    document.getElementById("closeDisplay").style.display = "none";
    document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
}

function onDocumentMouseOut() {

    document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
    document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
    document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

}

function onDocumentTouchStart( event ) {
    touchScreen = true;
    console.log("Touch");
    if ( event.touches.length == 1 ) {

        //event.preventDefault();

        mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
        targetRotationOnMouseDownx = targetRotationx;
        mouseYOnMouseDown = event.touches[ 0 ].pageY - windowHalfY;
        targetRotationOnMouseDowny = targetRotationy;

    }

}

function onDocumentTouchMove( event ) {

    if ( event.touches.length == 1 ) {

        //event.preventDefault();

        mouseX = event.touches[ 0 ].pageX - windowHalfX;
        targetRotationx = targetRotationOnMouseDownx + ( mouseX - mouseXOnMouseDown ) * 0.02;
        mouseY = event.touches[ 0 ].pageY - windowHalfY;
        targetRotationy = targetRotationOnMouseDowny - ( mouseY - mouseYOnMouseDown ) * 0.02;
    }

}

function onDocumentMouseWheel( event ) {

    //camera.position.set (0,0,camera.position.z + event.wheelDeltaY * 0.1);
    moveCamTo.z = camera.position.z + event.wheelDeltaY * 0.1;
    if (moveCamTo.z < -400){
        moveCamTo.z = -400;
    }
    if (moveCamTo.z > -40){
        moveCamTo.z = -40;
    }


}

//

function animate() {

    requestAnimationFrame( animate );

    render();

}

function render() {
    var doClick = false;
    
    if (!doDisplay){
        if (doRaycast){
            // find intersections
            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( onOffCubes, true );
            if ( intersects.length > 0 ) {
                if (intersects[ 0 ].object.type == "Mesh"){
                    if ( INTERSECTED != intersects[ 0 ].object ) {
                        if ( INTERSECTED != null ){
                            INTERSECTED.material.emissive.setHex( 0x000000 );
                        }
                        INTERSECTED = intersects[ 0 ].object;
                        INTERSECTED.material.emissive.setHex( 0x00ff00 );
                    } else if (touchScreen) {
                        doClick = true;
                    }
                }
            } else {
                if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( 0x000000 );
                INTERSECTED = null;
            }
            doRaycast = false;
        }
        
        targetRotationx += 0.001 * rotationDirectionx;
        targetRotationy += 0.001 * rotationDirectiony;

        group.rotation.y += ( targetRotationx - group.rotation.y ) * 0.05;
        group.rotation.x += ( targetRotationy - group.rotation.x ) * 0.05;

    } else {
        targetRotationx = 0;
        targetRotationy = 0;

        group.rotation.y += ( targetRotationx - group.rotation.y ) * 0.05;
        group.rotation.x += ( targetRotationy - group.rotation.x ) * 0.05;

        if (group.rotation.y > 0.0001 || group.rotation.y < 0.0001){
            group.rotation.y += ( targetRotationx - group.rotation.y ) * 0.05;
        } else {
            group.rotation.y = 0;
        }

        if (group.rotation.x > 0.0001 || group.rotation.x < 0.0001){
            group.rotation.x += ( targetRotationy - group.rotation.x ) * 0.05;
        } else {
            group.rotation.x = 0;
        }
    }

    if (camera.position.x != moveCamTo.x){
        if (camera.position.x > moveCamTo.x){
            if ((camera.position.x - 0.01) < moveCamTo.x){
                //console.log("Done");
                camera.position.x = moveCamTo.x;	
            } else {
                //console.log("Adjust");
                camera.position.x = camera.position.x - ((moveCamTo.x - camera.position.x)/-10);
            }
        } else if (camera.position.x < moveCamTo.x){
            if ((camera.position.x + 0.01) > moveCamTo.x){
                //console.log("Done");
                camera.position.x = moveCamTo.x;	
            } else {
                //console.log("Adjust");
                camera.position.x = camera.position.x + ((moveCamTo.x - camera.position.x)/10);
            }
        }
    }

    if (camera.position.y != moveCamTo.y){
        if (camera.position.y > moveCamTo.y){
            if ((camera.position.y - 0.01) < moveCamTo.y){
                //console.log("Done");
                camera.position.y = moveCamTo.y;	
            } else {
                //console.log("Adjust");
                camera.position.y = camera.position.y - ((moveCamTo.y - camera.position.y)/-10);
            }
        } else if (camera.position.y < moveCamTo.y){
            if ((camera.position.y + 0.01) > moveCamTo.y){
                //console.log("Done");
                camera.position.y = moveCamTo.y;	
            } else {
                //console.log("Adjust");
                camera.position.y = camera.position.y + ((moveCamTo.y - camera.position.y)/10);
            }
        }
    }

    if (camera.position.z != moveCamTo.z){
        if (camera.position.z > moveCamTo.z){
            if ((camera.position.z - 0.01) < moveCamTo.z){
                //console.log("Done");
                camera.position.z = moveCamTo.z;	
            } else {
                //console.log("Adjust");
                camera.position.z = camera.position.z - ((moveCamTo.z - camera.position.z)/-10);
            }
        } else if (camera.position.z < moveCamTo.z){
            if ((camera.position.z + 0.01) > moveCamTo.z){
                //console.log("Done");
                camera.position.z = moveCamTo.z;	
            } else {
                //console.log("Adjust");
                camera.position.z = camera.position.z + ((moveCamTo.z - camera.position.z)/10);
            }
        }
    }


    
    renderer.render( scene, camera );
    if (doClick) onHexClick();
}

